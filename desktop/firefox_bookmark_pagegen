#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import print_function

import itertools as it, operator as op, functools as ft
from os.path import join, exists, isfile, isdir, expanduser
from contextlib import closing
from collections import defaultdict, OrderedDict
import os, sys, io, sqlite3, ConfigParser


class AdHocException(Exception): pass

def get_profile_dir(profile):
	if profile:
		if profile.startswith(os.sep): return profile
		profile = profile.lower() # for ci comparisons

	ff_home = expanduser('~/.mozilla/firefox')
	profiles = ConfigParser.RawConfigParser()
	profiles.read(join(ff_home, 'profiles.ini'))

	profile_path, paths = None, list()
	for k in profiles.sections():
		if not k.startswith('Profile'): continue
		name = profiles.get(k, 'Name').strip().lower()
		path = profiles.get(k, 'Path')
		if profile is not None and name == profile:
			profile_path = path
			break
		if profile:
			paths.append(path)
			continue
		if profile_path: continue
		try:
			if not profiles.getboolean(k, 'Default'): raise AdHocException
		except (ConfigParser.NoOptionError, AdHocException): pass
		else: profile_path = path
	else:
		for path in paths:
			if profile in path.lower():
				profile_path = path
				break
		assert profile_path, profile

	profile_path = join(ff_home, profile_path)
	assert isdir(profile_path), [name, profile_path]
	return profile_path


def sqlite_dict_row(cursor, row):
	row = sqlite3.Row(cursor, row)
	return dict((k, row[k]) for k in row.keys())

def get_bookmarks(db_path, timeout=30):
	assert isfile(db_path), db_path
	bms = defaultdict(lambda: dict(bm_tags=set()))

	with sqlite3.connect(db_path, timeout=timeout) as conn:
		conn.row_factory = sqlite_dict_row
		with closing(conn.cursor()) as c:
			c.execute('select * from moz_bookmarks')
			bm_data = c.fetchall()

			bms_meta = dict()
			for r in bm_data:
				t, fk = r['type'], r['fk']
				if t == 1 and r['title'] is not None:
					bm = dict(bm_title=r['title'], bm_added=r['dateAdded'], bm_folder=r['parent'])
					c.execute('select * from moz_places where id = ?', (fk,))
					p = c.fetchone()
					if p is None or p['hidden']:
						if p is None:
							log.warn('Missing moz_places entry for bookmark, ignoring: %s', r)
						bms[fk]['legit'] = False
						continue
					assert not set(bm).intersection(p), [bm, p]
					bm.update(p)
					bms[fk].update(bm)
					bms[fk].setdefault('legit', True)
				elif t == 1: bms[fk]['bm_tags'].add(r['parent']) # tag link
				elif t == 2: bms_meta[r['id']] = r['title']
				else: raise ValueError(r)

			for fk in bms.keys():
				if not bms[fk].pop('legit', False):
					del bms[fk]
					continue
				bm = bms[fk]
				# Tags
				bm_tags, tags = bm['bm_tags'], set()
				for t in bm_tags:
					try: tags.add(bms_meta[t])
					except KeyError:
						log.warn( 'Unknown tag id in'
							' bookmark-tag link, skipping: %s (bm: %s)', t, bm )
				bm_tags.clear()
				bm_tags.update(tags)
				# Path
				# XXX: subdir parents, if I'll ever use these
				try: bm['bm_folder'] = bms_meta[bm['bm_folder']]
				except KeyError:
					log.warn( 'Unknown parent folder id in'
						' bookmark-parent link, using "Unknown": %s (bm: %s)', bm['bm_folder'], bm )
					bm['bm_folder'] = 'Unknown'
				# Favicon
				# XXX: fetch missing ones maybe?
				favicon = bm.pop('favicon_id')
				if favicon:
					c.execute('select data, mime_type from moz_favicons where id = ?', (favicon,))
					favicon = c.fetchone()
				if favicon:
					bm['favicon'] = dict(
						mime_type=favicon['mime_type'],
						data=bytes(favicon['data']).encode('base64') )

	return bms


def generate_rst(bookmarks): # XXX: also use places and some form(s) of backlog files
	output = io.StringIO()
	p = lambda line,end=u'\n': print(unicode(line), end=end, file=output)

	def p_header(header, style=u'=', indent=u'', newlines=1):
		p(indent, end=u'')
		p(header)
		p(indent, end=u'')
		p(u'='*len(header))
		p(u'\n'*newlines, end=u'')

	links = OrderedDict()
	def p_link(title, url, tpl=None, tpl_cb=None, end=u'\n'):
		assert title not in links, title # XXX: append some token
		for c in '`:': assert c not in title, title
		link = u'`{}`_'.format(title)
		links[title] = url
		if tpl: p(unicode(tpl).format(link), end=end)
		elif tpl_cb: p(tpl(link), end=end)
		else: return link
	def p_link_urls(newlines_pre=1, newlines=0):
		p(u'\n'*newlines_pre, end=u'')
		for title, url in links.viewitems():
			p(u'.. _{}: {}'.format(title, url))
		links.clear()
		p(u'\n'*newlines, end=u'')

	p_header('Bookmarks')
	for bm in bookmarks.viewvalues():
		title = bm['bm_title'].replace('`', '')
		p_link(title, bm['url'], ' * {}')

	p_link_urls()

	return output.getvalue()




def main(args=None):
	import argparse
	parser = argparse.ArgumentParser(
		description='Tool to generate firefox homepage from bookmarks, history and other data.')

	parser.add_argument('-o', '--output', metavar='format', choices=['rst', 'html'], default='html',
		help='Output format. Possible choices: rst, html (default: %(default)s).')

	parser.add_argument('-P', '--profile', metavar='name/key/path',
		help='Full firefox profile name, profile directory name'
			' or its fragment, or a full path to profile dir (default: use default profile).')
	parser.add_argument('-t', '--db-lock-timeout',
		type=float, metavar='seconds', default=30,
		help='Timeout to acquire sqlite transaction locks (default: %(default)ss).')

	parser.add_argument('-d', '--debug', action='store_true', help='Verbose operation mode.')
	opts = parser.parse_args(sys.argv[1:] if args is None else args)

	global log
	import logging
	logging.basicConfig(level=logging.DEBUG if opts.debug else logging.WARNING)
	log = logging.getLogger()

	if opts.debug:
		global pyaml, dump
		try:
			import pyaml
		except ImportError:
			# Only crash when/if this debug printer actually gets used
			err_type, err_val, err_tb = sys.exc_info()
			def pyaml_dump(*args,**kws): raise err_type, err_val, err_tb
			pyaml = type('pyaml_mock', (object,), dict(dump=pyaml_dump))()
		else:
			pyaml.UnsafePrettyYAMLDumper.add_representer(
				sqlite3.Row, lambda s,o: s.represent_dict(dict((k, o[k]) for k in o.keys())) )
		dump = ft.partial(pyaml.dump, dst=sys.stdout)

	profile_dir = get_profile_dir(opts.profile)
	log.debug('Using ff profile dir: %s', profile_dir)

	bookmarks = get_bookmarks(join(profile_dir, 'places.sqlite'), timeout=opts.db_lock_timeout)
	# XXX: get_places()
	# XXX: get_backlog()
	out = generate_rst(bookmarks)
	if opts.output == 'html':
		raise NotImplementedError
		# XXX: generate_html(out)

	sys.stdout.write(out.encode('utf-8'))


if __name__ == '__main__': sys.exit(main())
