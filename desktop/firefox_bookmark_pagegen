#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import print_function

from os.path import join, exists, isfile, isdir, expanduser
from contextlib import closing
from collections import defaultdict
import os, sys, sqlite3, ConfigParser


class AdHocException(Exception): pass

def get_profile_dir(profile):
	if profile:
		if profile.startswith(os.sep): return profile
		profile = profile.lower() # for ci comparisons

	ff_home = expanduser('~/.mozilla/firefox')
	profiles = ConfigParser.RawConfigParser()
	profiles.read(join(ff_home, 'profiles.ini'))

	profile_path, paths = None, list()
	for k in profiles.sections():
		if not k.startswith('Profile'): continue
		name = profiles.get(k, 'Name').strip().lower()
		path = profiles.get(k, 'Path')
		if profile is not None and name == profile:
			profile_path = path
			break
		if profile:
			paths.append(path)
			continue
		if profile_path: continue
		try:
			if not profiles.getboolean(k, 'Default'): raise AdHocException
		except (ConfigParser.NoOptionError, AdHocException): pass
		else: profile_path = path
	else:
		for path in paths:
			if profile in path.lower():
				profile_path = path
				break
		assert profile_path, profile

	profile_path = join(ff_home, profile_path)
	assert isdir(profile_path), [name, profile_path]
	return profile_path


def sqlite_dict_row(cursor, row):
	row = sqlite3.Row(cursor, row)
	return dict((k, row[k]) for k in row.keys())

def get_bookmarks(db_path, timeout=30):
	assert isfile(db_path), db_path
	bms = defaultdict(lambda: dict(bm_tags=set()))

	with sqlite3.connect(db_path, timeout=timeout) as conn:
		conn.row_factory = sqlite_dict_row
		with closing(conn.cursor()) as c:
			c.execute('select * from moz_bookmarks')
			bm_data = c.fetchall()

			bms_meta = dict()
			for r in bm_data:
				t, fk = r['type'], r['fk']
				if t == 1 and r['title'] is not None:
					bm = dict(bm_title=r['title'], bm_added=r['dateAdded'], bm_folder=r['parent'])
					c.execute('select * from moz_places where id = ?', (fk,))
					p = c.fetchone()
					if p is None or p['hidden']:
						if p is None:
							log.warn('Missing moz_places entry for bookmark, ignoring: %s', r)
						bms[fk]['legit'] = False
						continue
					assert not set(bm).intersection(p), [bm, p]
					bm.update(p)
					bms[fk].update(bm)
					bms[fk].setdefault('legit', True)
				elif t == 1: bms[fk]['bm_tags'].add(r['parent']) # tag link
				elif t == 2: bms_meta[r['id']] = r['title']
				else: raise ValueError(r)

			for fk in bms.keys():
				if not bms[fk].pop('legit', False):
					del bms[fk]
					continue
				bm = bms[fk]
				# Tags
				bm_tags, tags = bm['bm_tags'], set()
				for t in bm_tags:
					try: tags.add(bms_meta[t])
					except KeyError:
						log.warn( 'Unknown tag id in'
							' bookmark-tag link, skipping: %s (bm: %s)', t, bm )
				bm_tags.clear()
				bm_tags.update(tags)
				# Path
				# XXX: subdir parents, if I'll ever use these
				try: bm['bm_folder'] = bms_meta[bm['bm_folder']]
				except KeyError:
					log.warn( 'Unknown parent folder id in'
						' bookmark-parent link, using "Unknown": %s (bm: %s)', bm['bm_folder'], bm )
					bm['bm_folder'] = 'Unknown'
				# Favicon
				# XXX: fetch missing ones maybe?
				favicon = bm.pop('favicon_id')
				if favicon:
					c.execute('select data, mime_type from moz_favicons where id = ?', (favicon,))
					favicon = c.fetchone()
				if favicon:
					bm['favicon'] = dict(
						mime_type=favicon['mime_type'],
						data=bytes(favicon['data']).encode('base64') )

	return bms


def main(args=None):
	import argparse
	parser = argparse.ArgumentParser(
		description='Tool to generate firefox homepage from bookmarks, history and other data.')

	parser.add_argument('-P', '--profile', metavar='name/key/path',
		help='Full firefox profile name, profile directory name'
			' or its fragment, or a full path to profile dir (default: use default profile).')
	parser.add_argument('-t', '--db-lock-timeout',
		type=float, metavar='seconds', default=30,
		help='Timeout to acquire sqlite transaction locks (default: %(default)ss).')

	parser.add_argument('-d', '--debug', action='store_true', help='Verbose operation mode.')
	opts = parser.parse_args(sys.argv[1:] if args is None else args)

	global log
	import logging
	logging.basicConfig(level=logging.DEBUG if opts.debug else logging.WARNING)
	log = logging.getLogger()

	if opts.debug:
		try:
			import pyaml
		except ImportError:
			# Only crash when/if this debug printer actually gets used
			err_type, err_val, err_tb = sys.exc_info()
			def pyaml_dump(*args,**kws): raise err_type, err_val, err_tb
			pyaml = type('pyaml_mock', (object,), dict(dump=pyaml_dump))()
		else:
			pyaml.UnsafePrettyYAMLDumper.add_representer(
				sqlite3.Row, lambda s,o: s.represent_dict(dict((k, o[k]) for k in o.keys())) )


	profile_dir = get_profile_dir(opts.profile)
	log.debug('Using ff profile dir: %s', profile_dir)

	bookmarks = get_bookmarks(join(profile_dir, 'places.sqlite'), timeout=opts.db_lock_timeout)

	pyaml.dump(bookmarks, sys.stdout)
	exit()

	generate_rst(bookmarks, places, backlog)


if __name__ == '__main__': sys.exit(main())
